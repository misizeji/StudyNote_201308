

char *p = malloc(0);

首先来解释malloc(0);


这个语法是对的，而且确实也分配了内存，但是内存空间是0，就是说返回给你的指针是不能用的，
感觉奇怪吧？但是从操作系统的原理来解释就不奇怪了，这要涉及操作系统维护内存的方法来说了，
在内存管理中，内存被分为2部分，栈和堆，栈有自己的机器指令，是一个先进后出的数据结构，我
就在这里不再过多解释了，malloc分配的内存是堆内存，由于堆没有自己的机器指令，所以要有系
统自己编写算法来管理这片内存，通常的做法是用链表，在每片被分配的内存前加个表头，里面存
储了被分配内存的起始地址和大小，你的malloc返回的就是表头里的起始指针，这个地址是由一系
列的算法得来了，通常不会为0，一旦分配成功，就返回一个有效的指针，对于分配0空间来说，算
法已经算出可用内存的起始地址，但是你占用0空间，所以对那个指针操作就是错误的，操作系统一
般不知道其终止地址，因为有占用大小就可以推出终止地址，还有就是即使分配0空间也要释放它，
其实是释放的链表结点还有，返回的指针是可用地址的起始地址，虽然你可以无限赋值，但是其实是
错误的，因为可能有其他有用的数据在那一片区域，如果指针越界就会出现意想不到的事情;
